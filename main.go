package main

import (
	"encoding/json"
	"flag"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strings"
)

var stringsMap = make(map[string]string)
var parenthesisRegexp = regexp.MustCompile(`{{(\w+)}}`)

func main() {
	localFileFlag, remoteFileFlag, gitlabAPITokenFlag, printToConsoleFlag, printToFileFlag := decalreFlags()
	var file *[]byte

	if *localFileFlag != "" {
		file = getLocalFile(*localFileFlag)
	} else if *remoteFileFlag != "" && *gitlabAPITokenFlag != "" {
		file = downloadFileViaGitlab(*remoteFileFlag, *gitlabAPITokenFlag)
	} else if *remoteFileFlag != "" {
		file = downloadFile(*remoteFileFlag)
	}

	if file == nil {
		log.Println("Sorry, no input was provided")
		os.Exit(1)
	}

	// Parse JSON
	data := make(map[string]interface{})
	err := json.Unmarshal(*file, &data)
	if err != nil {
		log.Println("Error when parsing JSON", err)
		os.Exit(1)
	}
	parseJSON(data, "")

	// Sort keys
	var keys []string
	for key := range stringsMap {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Convert to XML
	output := convertToXML(keys)

	// Print to console
	if *printToConsoleFlag {
		printToConsole(output)
	}

	// Print to file
	if *printToFileFlag {
		outputBytes := []byte(*output)
		printToFile(&outputBytes, "src/main/res/values", "strings.xml")
	}
}

// Declare flags and get their values
func decalreFlags() (localFileFlag *string, remoteFileFlag *string, gitlabAPITokenFlag *string, printToConsoleFlag *bool, printToFileFlag *bool) {
	localFileFlag = flag.String("local", "", "Local i18next file absolute address")
	remoteFileFlag = flag.String("remote", "", "Remote i18next file url")
	gitlabAPITokenFlag = flag.String("gitlab", "", "Gitlab token to get remote i18next file via Gitlab API")
	printToConsoleFlag = flag.Bool("console", false, "If set, print output to console")
	printToFileFlag = flag.Bool("write", true, "If set, print output to strings.xml")

	flag.Parse()

	return
}

// Print given bytes to console as string
func printToConsole(output *string) {
	print(*output)
}

// Print given bytes into file at given path with given filename
func printToFile(bytes *[]byte, path string, filename string) {
	if err := os.MkdirAll(path, os.ModePerm); err != nil {
		log.Println("Error when creating path", err)
	}

	if err := ioutil.WriteFile(path+"/"+filename, *bytes, os.ModePerm); err != nil {
		log.Println("Error when writing file", err)
	}
}

// Convert data to XML format
func convertToXML(orderedKeys []string) *string {
	output := "<!-- This file is autogenerated by i18nextToAndroidConverter -->\n" +
		"<!-- You should not modify it directly -->\n" +
		"<!-- Instead make all edits in your i18next file or repository -->\n\n" +
		"<resources>"

	for _, key := range orderedKeys {
		output += "\n    <string name=\"" + key + "\">" + stringsMap[key] + "</string>"
	}

	output += "\n</resources>"

	return &output
}

// Parse JSON recursively and write data to stringsMap
func parseJSON(data map[string]interface{}, prefix string) {
	for key, value := range data {
		var finalKey string
		if prefix == "" {
			finalKey = key
		} else {
			finalKey = prefix + "_" + key
		}

		if stringValue, ok := value.(string); ok == true {
			// Some additional processing
			stringValue = escapeApostrophes(stringValue)
			stringValue = escapeNewlines(stringValue)
			stringValue = escapeAmpersand(stringValue)
			stringValue = removeExtraParenthesis(stringValue)
			stringValue = replaceEllipsis(stringValue)

			stringsMap[strings.ToLower(finalKey)] = stringValue
		} else {
			newData := value.(map[string]interface{})
			parseJSON(newData, finalKey)
		}
	}
}

// Convert all apostrophes to escaped apostrophes
func escapeApostrophes(stringValue string) string {
	return strings.ReplaceAll(stringValue, "'", "\\'")
}

// Convert all newlines to escaped newlines
func escapeNewlines(stringValue string) string {
	return strings.ReplaceAll(stringValue, "\n", "\\n")
}

// Replace ampersands with appropriate symbols
func escapeAmpersand(stringValue string) string {
	return strings.ReplaceAll(stringValue, "&", "&amp;")
}

// Convert variables {{variable}} to just {variable}
func removeExtraParenthesis(stringValue string) string {
	return parenthesisRegexp.ReplaceAllString(stringValue, "{$1}")
}

// Replace ellipsis with appropriate symbol
func replaceEllipsis(stringValue string) string {
	return strings.ReplaceAll(stringValue, "...", "â€¦")
}

// Get local file
func getLocalFile(path string) *[]byte {
	file, err := ioutil.ReadFile(path)
	if err != nil {
		log.Println("Error when reading local file", err)
	}
	return &file
}

// Download file via Gitlab API
func downloadFileViaGitlab(url string, token string) (file *[]byte) {
	client := &http.Client{}

	request, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println("Error when making request", err)
		return
	}

	request.Header.Set("PRIVATE-TOKEN", token)

	response, err := client.Do(request)
	if err != nil {
		log.Println("Error when sending request", err)
		return
	}

	defer func() {
		err := response.Body.Close()
		if err != nil {
			log.Println("Error when closing connection", err)
			return
		}
	}()

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Println("Error when reading response", err)
		return
	}

	return &body
}

// Download file by url
func downloadFile(url string) (file *[]byte) {
	res, err := http.Get(url)
	if err != nil {
		log.Println("Error when making request", err)
		return
	}

	defer func() {
		err := res.Body.Close()
		if err != nil {
			log.Println("Error when closing connection", err)
			return
		}
	}()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Println("Error when reading response", err)
		return
	}

	return &body
}
