// Created by Alexander Mishchenko in 2019

package main

import (
	"encoding/json"
	"flag"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strings"
)

type flagsArray []string

var stringsMap map[string]string
var parenthesisRegexp = regexp.MustCompile(`{{(\w+)}}`)

func main() {
	localFilesFlags, remoteFilesFlags, gitlabAPITokenFlag, printToConsoleFlag, outputModifiers := decalreFlags()

	if len(localFilesFlags) > 0 {
		for index, localFileFlag := range localFilesFlags {
			file := getLocalFile(localFileFlag)
			var outputModifier *string

			if len(outputModifiers) < index + 1 {
				outputModifier = nil
			} else {
				outputModifier = &outputModifiers[index]
			}

			convertFile(file, printToConsoleFlag, outputModifier)
		}
	} else if len(remoteFilesFlags) > 0 && *gitlabAPITokenFlag != "" {
		for index, remoteFileFlag := range remoteFilesFlags {
			file := downloadFileViaGitlab(remoteFileFlag, *gitlabAPITokenFlag)
			var outputModifier *string

			if len(outputModifiers) < index + 1 {
				outputModifier = nil
			} else {
				outputModifier = &outputModifiers[index]
			}

			convertFile(file, printToConsoleFlag, outputModifier)
		}
	} else if len(remoteFilesFlags) > 0 {
		for index, remoteFileFlag := range remoteFilesFlags {
			file := downloadFile(remoteFileFlag)
			var outputModifier *string

			if len(outputModifiers) < index + 1 {
				outputModifier = nil
			} else {
				outputModifier = &outputModifiers[index]
			}

			convertFile(file, printToConsoleFlag, outputModifier)
		}
	} else {
		log.Println("Sorry, no input was provided")
		os.Exit(1)
	}
}

// Do actual work of converting i18next file to Android strings XML
func convertFile(file *[]byte, printToConsoleFlag *bool, outputModifier *string) {
	stringsMap = make(map[string]string)

	if file == nil {
		log.Println("Sorry, file cannot be read")
		os.Exit(1)
	}

	// Parse JSON
	data := make(map[string]interface{})
	err := json.Unmarshal(*file, &data)
	if err != nil {
		log.Println("Error when parsing JSON", err)
		os.Exit(1)
	}
	parseJSON(data, "")

	// Sort keys
	var keys []string
	for key := range stringsMap {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Convert to XML
	output := convertToXML(keys)

	// Print to console
	if *printToConsoleFlag {
		printToConsole(output)
	}

	// Print to file
	if outputModifier != nil {
		outputBytes := []byte(*output)

		var valuesFolderName string
		if *outputModifier == "" {
			valuesFolderName = "values"
		} else {
			valuesFolderName = "values-" + *outputModifier
		}

		printToFile(&outputBytes, "src/main/res/" + valuesFolderName, "strings.xml")
	}
}

// Declare flags and get their values
func decalreFlags() (localFilesFlags flagsArray, remoteFilesFlags flagsArray, gitlabAPITokenFlag *string, printToConsoleFlag *bool, outputModifiers flagsArray) {
	flag.Var(&localFilesFlags, "local", "Local i18next file absolute address.")
	flag.Var(&remoteFilesFlags, "remote", "Remote i18next file url.")
	gitlabAPITokenFlag = flag.String("gitlab", "", "Gitlab token to get remote i18next file via Gitlab Rest API.")
	printToConsoleFlag = flag.Bool("console", false, "If set, print output to console.")
	flag.Var(&outputModifiers, "write", "Android resource modifier that specifies values-XXX folder. Can be empty \"\". If not set, output won't be written to a file.")

	flag.Parse()

	return
}

// Add a new flag to the array
func (flags *flagsArray) Set(value string) error {
  *flags = append(*flags, value)
	return nil
}

// String representation of the array
func (flags *flagsArray) String() string {
	result := ""
  for index, flag := range *flags {
		if index > 0 {
			result += ","
		}
		result += flag
	}

	return result
}

// Print given bytes to console as string
func printToConsole(output *string) {
	print(*output)
}

// Print given bytes into file at given path with given filename
func printToFile(bytes *[]byte, path string, filename string) {
	if err := os.MkdirAll(path, os.ModePerm); err != nil {
		log.Println("Error when creating path", err)
	}

	if err := ioutil.WriteFile(path+"/"+filename, *bytes, os.ModePerm); err != nil {
		log.Println("Error when writing file", err)
	}
}

// Convert data to XML format
func convertToXML(orderedKeys []string) *string {
	output := "<!-- This file is autogenerated by i18nextToAndroidConverter -->\n" +
		"<!-- You should not modify it directly -->\n" +
		"<!-- Instead make all edits in your i18next file or repository -->\n\n" +
		"<resources>"

	for _, key := range orderedKeys {
		output += "\n    <string name=\"" + key + "\">" + stringsMap[key] + "</string>"
	}

	output += "\n</resources>"

	return &output
}

// Parse JSON recursively and write data to stringsMap
func parseJSON(data map[string]interface{}, prefix string) {
	for key, value := range data {
		var finalKey string
		if prefix == "" {
			finalKey = key
		} else {
			finalKey = prefix + "_" + key
		}

		if stringValue, ok := value.(string); ok == true {
			// Some additional processing
			stringValue = escapeApostrophes(stringValue)
			stringValue = escapeNewlines(stringValue)
			stringValue = escapeAmpersand(stringValue)
			stringValue = removeExtraParenthesis(stringValue)
			stringValue = replaceEllipsis(stringValue)

			stringsMap[strings.ToLower(finalKey)] = stringValue
		} else {
			newData := value.(map[string]interface{})
			parseJSON(newData, finalKey)
		}
	}
}

// Convert all apostrophes to escaped apostrophes
func escapeApostrophes(stringValue string) string {
	return strings.ReplaceAll(stringValue, "'", "\\'")
}

// Convert all newlines to escaped newlines
func escapeNewlines(stringValue string) string {
	return strings.ReplaceAll(stringValue, "\n", "\\n")
}

// Replace ampersands with appropriate symbols
func escapeAmpersand(stringValue string) string {
	return strings.ReplaceAll(stringValue, "&", "&amp;")
}

// Convert variables {{variable}} to just {variable}
func removeExtraParenthesis(stringValue string) string {
	return parenthesisRegexp.ReplaceAllString(stringValue, "{$1}")
}

// Replace ellipsis with appropriate symbol
func replaceEllipsis(stringValue string) string {
	return strings.ReplaceAll(stringValue, "...", "â€¦")
}

// Get local file
func getLocalFile(path string) *[]byte {
	file, err := ioutil.ReadFile(path)
	if err != nil {
		log.Println("Error when reading local file", err)
	}
	return &file
}

// Download file via Gitlab API
func downloadFileViaGitlab(url string, token string) (file *[]byte) {
	client := &http.Client{}

	request, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println("Error when making request", err)
		return
	}

	request.Header.Set("PRIVATE-TOKEN", token)

	response, err := client.Do(request)
	if err != nil {
		log.Println("Error when sending request", err)
		return
	}

	defer func() {
		err := response.Body.Close()
		if err != nil {
			log.Println("Error when closing connection", err)
			return
		}
	}()

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Println("Error when reading response", err)
		return
	}

	return &body
}

// Download file by url
func downloadFile(url string) (file *[]byte) {
	res, err := http.Get(url)
	if err != nil {
		log.Println("Error when making request", err)
		return
	}

	defer func() {
		err := res.Body.Close()
		if err != nil {
			log.Println("Error when closing connection", err)
			return
		}
	}()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Println("Error when reading response", err)
		return
	}

	return &body
}
